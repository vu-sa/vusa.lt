<?php

namespace App\Console\Commands;

use App\Services\Typesense\TypesenseCollectionConfig;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Cache;
use Typesense\Client;

class RotateTypesenseKeys extends Command
{
    /**
     * The name and signature of the console command.
     */
    protected $signature = 'typesense:rotate-keys
                            {--force : Skip confirmation prompts}
                            {--delete-old : Delete old API keys from Typesense}';

    /**
     * The console command description.
     */
    protected $description = 'Rotate all Typesense API keys (public search key and admin search key)';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        $this->info('ðŸ”„ Typesense Key Rotation');
        $this->newLine();

        // Check if Typesense is configured
        $adminKey = config('scout.typesense.client-settings.api_key');
        if (empty($adminKey)) {
            $this->error('âŒ TYPESENSE_API_KEY is not configured in .env file');
            $this->info('Please set a secure admin API key first.');

            return 1;
        }

        // Show current key info
        $this->showCurrentKeyInfo();

        // Confirm rotation
        if (! $this->option('force')) {
            $this->newLine();
            $this->warn('âš ï¸  This will generate new API keys and update your .env file.');
            $this->warn('   Old keys will become invalid after this process.');

            if (! $this->confirm('Do you want to proceed with key rotation?')) {
                $this->info('Key rotation cancelled.');

                return 0;
            }
        }

        try {
            $client = app(Client::class);
            $oldKeyIds = [];

            // Get old key IDs if we need to delete them
            if ($this->option('delete-old')) {
                $oldKeyIds = $this->getExistingKeyIds($client);
            }

            $this->newLine();
            $this->info('ðŸ“¦ Step 1/4: Generating new public search-only key...');
            $publicResult = $this->generatePublicKey($client);
            if ($publicResult !== 0) {
                return $publicResult;
            }

            $this->newLine();
            $this->info('ðŸ“¦ Step 2/4: Generating new admin search-only key...');
            $adminResult = $this->generateAdminKey($client);
            if ($adminResult !== 0) {
                return $adminResult;
            }

            $this->newLine();
            $this->info('ðŸ“¦ Step 3/4: Invalidating cached scoped keys...');
            $this->invalidateScopedKeyCache();

            if ($this->option('delete-old') && ! empty($oldKeyIds)) {
                $this->newLine();
                $this->info('ðŸ“¦ Step 4/4: Deleting old keys from Typesense...');
                $this->deleteOldKeys($client, $oldKeyIds);
            } else {
                $this->info('ðŸ“¦ Step 4/4: Skipping old key deletion (use --delete-old to enable)');
            }

            $this->newLine();
            $this->info('âœ… Key rotation completed successfully!');
            $this->newLine();

            $this->showCollectionInfo();

            return 0;

        } catch (\Exception $e) {
            $this->error('âŒ Key rotation failed: '.$e->getMessage());

            if (str_contains($e->getMessage(), 'Connection refused')) {
                $this->warn('ðŸ’¡ Make sure Typesense server is running:');
                $this->line('   ./vendor/bin/sail up -d');
            }

            return 1;
        }
    }

    /**
     * Show current key information
     */
    private function showCurrentKeyInfo(): void
    {
        $this->info('ðŸ“Š Current Key Status:');

        $publicKey = config('scout.typesense.client-settings.search_only_key');
        $adminSearchKey = config('scout.typesense.client-settings.admin_search_key');

        $this->table(
            ['Key Type', 'Status'],
            [
                ['Public Search Key', $publicKey ? 'âœ… Configured' : 'âŒ Not set'],
                ['Admin Search Key', $adminSearchKey ? 'âœ… Configured' : 'âŒ Not set'],
            ]
        );
    }

    /**
     * Get existing key IDs that match our descriptions
     */
    private function getExistingKeyIds(Client $client): array
    {
        $keyIds = [];

        try {
            $keys = $client->keys->retrieve();

            foreach ($keys['keys'] ?? [] as $key) {
                $description = $key['description'] ?? '';
                if (
                    str_contains($description, 'generated by Laravel') ||
                    str_contains($description, 'Search-only key for public frontend') ||
                    str_contains($description, 'Admin search-only key')
                ) {
                    $keyIds[] = $key['id'];
                }
            }
        } catch (\Exception $e) {
            $this->warn('Could not retrieve existing keys: '.$e->getMessage());
        }

        return $keyIds;
    }

    /**
     * Generate new public search key
     */
    private function generatePublicKey(Client $client): int
    {
        $publicCollections = TypesenseCollectionConfig::getPublicCollectionNames();

        $keyResponse = $client->keys->create([
            'description' => 'Search-only key for public frontend (generated by Laravel) - '.now()->toIso8601String(),
            'actions' => ['documents:search'],
            'collections' => $publicCollections,
        ]);

        $this->updateEnvKey('TYPESENSE_SEARCH_ONLY_KEY', $keyResponse['value']);
        $this->info('   âœ… Public key generated: '.substr($keyResponse['value'], 0, 8).'...');

        return 0;
    }

    /**
     * Generate new admin search key
     */
    private function generateAdminKey(Client $client): int
    {
        $adminCollections = TypesenseCollectionConfig::getAdminCollectionNames();

        $keyResponse = $client->keys->create([
            'description' => 'Admin search-only key for scoped key generation (generated by Laravel) - '.now()->toIso8601String(),
            'actions' => ['documents:search'],
            'collections' => $adminCollections,
        ]);

        $this->updateEnvKey('TYPESENSE_ADMIN_SEARCH_KEY', $keyResponse['value']);
        $this->info('   âœ… Admin key generated: '.substr($keyResponse['value'], 0, 8).'...');

        return 0;
    }

    /**
     * Invalidate all cached scoped keys
     */
    private function invalidateScopedKeyCache(): void
    {
        // Clear all scoped key caches using pattern
        // Since we can't easily iterate all user IDs, we'll recommend cache clear
        // or note that keys will regenerate on next request
        $cacheDriver = config('cache.default');

        if ($cacheDriver === 'redis') {
            // For Redis driver, use Redis facade for pattern deletion
            try {
                $prefix = config('cache.prefix');
                $pattern = $prefix.'typesense_scoped_keys:*';

                $redis = \Illuminate\Support\Facades\Redis::connection('cache');
                $keys = $redis->keys($pattern);

                if (! empty($keys)) {
                    // Keys from Redis may need prefix stripping for del command
                    $redis->del($keys);
                    $this->info('   âœ… Cleared '.count($keys).' cached scoped keys');

                    return;
                }

                $this->info('   â„¹ï¸  No cached scoped keys found');

                return;
            } catch (\Exception $e) {
                // Fall through to manual note
                $this->warn('   âš ï¸  Could not clear Redis cache: '.$e->getMessage());
            }
        }

        $this->info('   â„¹ï¸  Scoped keys will regenerate on next user request (cache TTL ~1 hour)');
        $this->info('   ðŸ’¡ Run "sail artisan cache:clear" to force immediate regeneration for all users');
    }

    /**
     * Delete old keys from Typesense
     */
    private function deleteOldKeys(Client $client, array $keyIds): void
    {
        $deleted = 0;

        foreach ($keyIds as $keyId) {
            try {
                $client->keys[$keyId]->delete();
                $deleted++;
            } catch (\Exception $e) {
                $this->warn("   Could not delete key {$keyId}: ".$e->getMessage());
            }
        }

        $this->info("   âœ… Deleted {$deleted} old key(s) from Typesense");
    }

    /**
     * Update a key in the .env file
     */
    private function updateEnvKey(string $keyName, string $keyValue): void
    {
        $envPath = base_path('.env');

        if (! file_exists($envPath)) {
            throw new \Exception('.env file not found');
        }

        $envContent = file_get_contents($envPath);

        if (preg_match("/^{$keyName}=/m", $envContent)) {
            $envContent = preg_replace(
                "/^{$keyName}=.*/m",
                "{$keyName}={$keyValue}",
                $envContent
            );
        } else {
            // Add after TYPESENSE_API_KEY
            if (preg_match('/^(TYPESENSE_API_KEY=.*)/m', $envContent)) {
                $envContent = preg_replace(
                    '/^(TYPESENSE_API_KEY=.*)/m',
                    "$1\n{$keyName}={$keyValue}",
                    $envContent
                );
            } else {
                $envContent .= "\n{$keyName}={$keyValue}\n";
            }
        }

        file_put_contents($envPath, $envContent);
    }

    /**
     * Show collection configuration info
     */
    private function showCollectionInfo(): void
    {
        $this->info('ðŸ“š Collection Configuration:');

        $collectionInfo = TypesenseCollectionConfig::getCollectionInfo();
        $tableData = [];

        foreach ($collectionInfo as $name => $info) {
            $tableData[] = [
                $name,
                $info['type'],
                $info['permission'] ?? '-',
                $info['prefixed_name'],
            ];
        }

        $this->table(
            ['Collection', 'Type', 'Permission', 'Prefixed Name'],
            $tableData
        );
    }
}
